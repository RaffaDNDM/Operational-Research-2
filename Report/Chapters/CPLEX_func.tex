\chapter{ILOG CPLEX}\label{CPLEX_func}
In questa sezione verranno approfondite alcune funzioni di CPLEX necessarie ad implementare gli algoritmi descritti nei capitoli precedenti.

\section{Funzionamento}
Per poter utilizzare gli algoritmi di risoluzione forniti da CPLEX è necessario costruire il modello matematico del problema, legato all'istanza precedentemente descritta.\\
CPLEX ha due meccanismi di acquisizione dell'istanza:
\begin{enumerate}
\item{\textbf{modalità interattiva}\\
in cui il modello viene letto da un file precedentemente generato (\textit{model.lp})}
\item{\textbf{creazione nel programma}\\
il modello viene creato attraverso le API del linguaggio usato per la scrittura del programma}
\end{enumerate}

Le strutture utilizzate da CPLEX sono due (vedi Figura \ref{strutture_cplex}):
\begin{itemize}
\item{\textbf{ENV:} contiene i parametri necessari all'esecuzione e al salvataggio dei risultati}
\item{\textbf{LP:} contiene il modello che viene analizzato da CPLEX durante la computazione del problema di ottimizzazione}
\end{itemize}

\begin{figure}[h] 
\begin{center} 
  \includegraphics[scale=0.7]{Images/cplex_structs}\\ 
  \caption{\footnotesize{Strutture CPLEX}}
  \label{strutture_cplex} 
\end{center} 
\end{figure}

Ad ogni ENV è possibile associare più LP, in modo da poter risolvere in parallelo più problemi di ottimizzazione, ma nel nostro caso ne sarà sufficiente solo uno.\\
Per convenzione è stato deciso di etichettare i rami $(i,j)$ dell'istanza rispettando la proprietà $i<j$. In Figura \ref{Indici_matrice} è riportato lo schema degli indici che vengono utilizzati per etichettare le variabili.\\
In questa figura le celle $(i,j)$ bianche, sono quelle effettivamente utilizzate per indicare un arco secondo la convenzione. Il numero all'interno di queste caselle rappresenta invece l'ordine in cui queste variabili vengono inserite nel modello e quindi gli indici associati da CPLEX per accedere alla soluzione.\\
\begin{figure}[h] 
\begin{center} 
  \includegraphics[scale=0.6]{Images/indices_matrix}\\ 
  \caption{\footnotesize{Indici della matrice}}
  \label{Indici_matrice} 
\end{center} 
\end{figure}

\section{Funzioni}
\subsection{Costruzione e modifica del modello}
Per poter costruire il modello da analizzare, come prima cosa, è necessario creare un puntatore alle due strutture dati utilizzate da CPLEX.
\lstinputlisting[caption={\footnotesize{modelTSP.txt}}, style=code, firstnumber=1, firstline=27, lastline=29, label=tsp_model, language=c]{Source/modelTSP.txt}
La funzione alla riga 2 alloca la memoria necessaria e riempie la struttura con valori di default. Nel caso in cui non termini con successo memorizza un codice d'errore in \textit{error}.\\
La funziona invocata nella riga successiva, invece, associa la struttura LP all'ENV che gli viene fornito. Il terzo parametro passato, nell'esempio "TSP", sarà il nome del modello. Al termine di queste operazioni verrà quindi creato un modello vuoto. All'interno del nostro programma per inizializzarlo è stata definita la seguente funzione:
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=370pt, basicstyle=\footnotesize\sffamily,] 
void cplex_build_model(tsp_instance* tsp_in, CPXENVptr env, CPXLPptr lp);
\end{lstlisting}
\end{tabular}
\end{center}
\begin{table}[h]
\centering
\begin{tabular}{rl}
\textbf{tsp\_in: } & {puntatore alla struttura che contiene l'istanza del problema (letta dal file TSPlib)} \\
\textbf{env: } & {puntatore alla struttura ENV precedentemente creata}\\
\textbf{lp: } & {puntatore alla struttura LP  precedentemente creata}\\
\end{tabular}
\end{table}
All'interno di \textbf{cplex\_build\_model()} viene aggiunta nel modello una colonna alla volta. Le variabili aggiunte corrispondono agli archi del grafo e per ciascuno di questi viene calcolato il costo come distanza euclidea. La funzione necessaria ad inserire colonne e definire la funzione di costo è la seguente:
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=400pt, basicstyle=\footnotesize\sffamily,] 
int CPXnewcols( CPXCENVptr env, CPXLPptr lp, int ccnt, double const * obj, 
		double const * lb, double const * ub, char const * xctype, char ** colname);    
\end{lstlisting}
\end{tabular}
\end{center}
\begin{table}[h]
\begin{tabular}{rl}
\textbf{env:} & {puntatore alla struttura ENV precedentemente creata}\\
\textbf{lp:} & {puntatore alla struttura LP precedentemente creata}\\
\textbf{ccnt:} & {numero di colonne da inserire} \\    
\textbf{obj:} & {vettore dei costi relativi agli archi da inserire} \\
\textbf{lb:} & {vettore contenente i lower bound dei valori assumibili dalle variabili da}\\
&{inserire}\\            
\textbf{ub:} & {vettore contenente gli upper bound dei valori assumibili dalle variabili da}\\
&{inserire}\\
\textbf{xctype:} & {vettore contenente la tipologia delle variabili da inserire}\\
\textbf{colname:} & {vettore di stringhe contenenti i nomi delle variabili da inserire}\\
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\
\end{tabular}
\end{table}
Tale funzione permette però di aggiungere più colonne contemporaneamente. Per questo la generica colonna \textbf{i}, aggiunta dalla funzione, sarà definita dalle informazioni contenute all'interno della posizione \textbf{i} degli array, ricevuti come parametri. Nel programma elaborato durante il corso, viene aggiunta una colonna alla volta all'interno del modello. Per far ciò, è necessario comunque utilizzare riferimenti alle variabili da aggiungere, in modo da ovviare il problema riguardante la tipologia di argomenti richiesti, che sono array. Ad esempio, nel nostro caso, la tipologia di una nuova variabile inserita sarà un puntatore al carattere \textbf{'B'}, che la identifica come binaria.\\
Per poter inserire il primo insieme di vincoli del problema\\
$$
\underset{e\in \delta(v)}\sum{\;x_e} = 2\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\forall\;v\in V \\\\
$$
\\
viene invece sfruttata la seguente funzione:
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=380pt, basicstyle=\footnotesize\sffamily,]  
int CPXnewrows( CPXCENVptr env, CPXLPptr lp, int rcnt, double const * rhs,
		char const * sense, double const * rngval, char ** rowname);   
\end{lstlisting}
\end{tabular}
\end{center}
\begin{table}[h]
\centering
\begin{tabular}{rl}
\textbf{env:} & {puntatore alla struttura ENV precedentemente creata}\\
\textbf{lp:} & {puntatore alla struttura LP precedentemente creata}\\
\textbf{rcnt:} & {numero di righe (vincoli) da inserire}\\
\textbf{rhs:} & {vettore dei termini noti dei vincoli}\\
\textbf{sense:} & {vettore di caratteri che specifica il tipo di vincoli da inserire.}\\
&{Ogni carattere può assumere:}\\
&{\textit{'L'} per vincolo $\leq$}\\
&{\textit{'E'} per vincolo $=$}\\
&{\textit{'G'} per vincolo $\geq$}\\
&{\textit{'R'} per vincolo definito in un intervallo}\\
\textbf{rngval:} & {vettore di range per i valori di ogni vincolo (nel nostro caso è NULL)}\\
\textbf{rowname} & {vettore di stringhe contenenti i nomi delle variabili da inserire}\\
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\
\end{tabular}
\end{table}
In modo analogo all'inserimento delle colonne, nel nostro programma viene aggiunta una riga alla volta nel modello. L'\textbf{i}-esima riga aggiunta corrisponderà al vincolo imposto sul nodo \textbf{i}-esimo, imponendo a 1 il coefficiente della variabile $x_{kj}$ se $k=i \;\wedge j=i$ per ogni variabile del modello. In questo modo però viene aggiunto un vincolo in cui è necessario cambiare i coefficienti delle variabili che ne prendono parte. Per fare ciò è necessaria la funzione:
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=380pt, basicstyle=\footnotesize\sffamily,]   
int CPXchgcoef(CPXCENVptr env, CPXLPptr lp, int i, int j, double newvalue);
\end{lstlisting}
\end{tabular}
\end{center}
\begin{table}[h]
\centering
\begin{tabular}{rl}
\textbf{env:} & {puntatore alla struttura ENV precedentemente creata}\\
\textbf{lp:} & {puntatore alla struttura LP precedentemente creata}\\
\textbf{i:} & {intero che specifica l'indice della riga in cui modificare il coefficiente}\\
\textbf{j:} & {intero che specifica la colonna in cui si trova la variabile per cui modificare}\\
&{il coefficiente}\\
\textbf{newvalue:} & {nuovo valore del coefficiente}\\
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\
\end{tabular}
\end{table}
L'utilizzo di \textbf{CPXnewrows()} insieme a \textbf{CPXchgcoef()} per inserire nuovi vincoli è però considerato inefficiente. Al suo posto è consigliato l'utilizzo della seguente funzione che inserisce il vincolo con già i coefficienti delle variabili impostati al valore corretto:
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=400pt, basicstyle=\footnotesize\sffamily,]  
int CPXaddrows( CPXCENVptr env, CPXLPptr lp, int ccnt, int rcnt, int nzcnt,
		double const * rhs, char const * sense, int const * rmatbeg, 
		int const * rmatind, double const * rmatval, char ** colname, 
		char ** rowname );   
\end{lstlisting}
\end{tabular}
\end{center}
\begin{table}[h]
\centering
\begin{tabular}{rl}
\textbf{env:} & {puntatore alla struttura ENV precedentemente creata}\\
\textbf{lp:} & {puntatore alla struttura LP precedentemente creata}\\
\textbf{ccnt:} & {numero di nuove colonne che devono essere aggiunte}\\
\textbf{rcnt:} & {numero di nuove righe che devono essere aggiunte}\\
\textbf{nzcnt:} & {numero di coefficienti non nulli nel vincolo aggiunto}\\
\textbf{rhs:} & {vettore con i termini noti per ogni vincolo da aggiungere}\\
\textbf{sense:} & {vettore con il tipo di vincoli da aggiungere, scelto tra:}\\
&{\textit{'L'} per vincolo $\leq$}\\
&{\textit{'E'} per vincolo $=$}\\
&{\textit{'G'} per vincolo $\geq$}\\
&{\textit{'R'} per vincolo definito in un intervallo}\\
\textbf{rmatbeg:} & {vettore con le posizioni iniziali dei coefficienti nei vincoli}\\
\textbf{rmatind:} & {vettore contenente gli indici delle variabili appartenenti al vincolo}\\
\textbf{rmatval:} & {vettore con i coefficienti delle variabili del vincolo}\\
\textbf{colname:} & {vettore contenente i nomi delle nuove colonne}\\
\textbf{rowname:} & {vettore contenente i nomi dei nuovi vincoli}\\
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\
\end{tabular}
\end{table}
Per rimuovere invece delle righe, viene utilizzata la seguente funzione:
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=330pt, basicstyle=\footnotesize\sffamily,]     
int CPXdelrows( CPXCENVptr env, CPXLPptr lp, int begin, int end );
\end{lstlisting}
\end{tabular}
\end{center}
\begin{table}[h]
\centering
\begin{tabular}{rl}
\textbf{env:} & {puntatore alla struttura ENV precedentemente creata}\\
\textbf{lp:} & {puntatore alla struttura LP precedentemente creata}\\
\textbf{begin:} & {indice numerico della prima riga da cancellare}\\
\textbf{end:} & {indice numerico dell'ultima riga da cancellare}\\
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\
\end{tabular}
\end{table} 
\vspace{2 cm}
Per poter impostare una variabile $x_{ij}$ ad una valore fissato è necessario assegnare al suo lower e al suo upper bound determinati valori tramite la seguente funzione:
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=375pt, basicstyle=\footnotesize\sffamily,]   
int CPXchgbds(CPXCENVptr env, CPXLPptr lp, int cnt, const int * indices, 
		const char * lu, const double * bd); 
\end{lstlisting}
\end{tabular}
\end{center}
\begin{table}[h]
\centering
\begin{tabular}{rl}
\textbf{env:} & {puntatore alla struttura ENV}\\
\textbf{lp:} & {puntatore alla struttura LP}\\
\textbf{cnt:} & {numero totale di bound da cambiare}\\
\textbf{indices:} & {vettore con gli indici delle colonne corrispondenti alle variabili}\\
&{per cui bisogna cambiare il bound}\\
\textbf{lu:} & {array di caratteri che specificano il bound da modificare.}\\
&{I possibili valori di tali caratteri sono:}\\
&{\textit{'U'} per selezionare l'upper bound}\\
&{\textit{'L'} per selezionare il lower bound}\\
&{\textit{'B'} per  selezionare entrambi i bound}\\
\textbf{bd:} & {vettore con i nuovi valori}\\
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\
\end{tabular}
\end{table}
\subsection{Calcolo della soluzione}
Per ottenere la soluzione ottima del problema di ottimizzazione, correlato al modello definito in CPLEX, vengono utilizzate due fasi:
\begin{itemize}
\item{\textbf{Risoluzione del problema di ottimizzazione}\\\\
\begin{tabular}{c}
\begin{lstlisting}[linewidth=220pt, basicstyle=\footnotesize\sffamily,]
int CPXmipopt(CPXCENVptr env, CPXLPptr lp);
\end{lstlisting}
\end{tabular}
\begin{table}[h]
\centering
\begin{tabular}{rl}
\textbf{env:} & {puntatore alla struttura ENV precedentemente creata}\\
\textbf{lp:} & {puntatore alla struttura LP precedentemente creata}\\
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\
\end{tabular}
\end{table}
}
\item{\textbf{Ottenimento della soluzione}\\\\
\begin{tabular}{c}
\begin{lstlisting}[linewidth=380pt, basicstyle=\footnotesize\sffamily,]
int CPXgetmipx (CPXENVptr env, CPXLPptr lp, double *x, int begin, int end);
\end{lstlisting}
\end{tabular}
\vspace{2 cm}
\begin{table}[h]
\centering
\begin{tabular}{rl}
\textbf{env:} & {puntatore alla struttura ENV precedentemente creata}\\
\textbf{lp:} & {puntatore alla struttura LP precedentemente creata}\\
\textbf{x:} & {puntatore a un vettore di double in cui verranno salvati i valori}\\
& {delle variabili ottenuti dalla soluzione ottima}\\
\textbf{begin:} & {primo indice della variabile di cui si vuole memorizzare ed analizzare}\\
&{ il valore}\\
\textbf{end:} & {indice dell'ultima variabile di cui si vuole memorizzare ed analizzare}\\
&{il valore}\\
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\
\end{tabular}
\end{table}
\\Questa funzione salva in $x$ tutte le variabili che hanno indice $i\in [begin, end]$ e quindi $x$ deve essere un vettore di almeno $end-begin+1$ valori. Nel nostro programma, vengono analizzati i valori di tutte le variabili definite \footnote{numero di variabili=CPXgetnumcols(env,lp);}\footnote{numero di vincoli=CPXgetnumrows(env,lp);}.\\
Per questo motivo \textbf{begin = 0} e 
\textbf{end = num\_colonne - 1}.\\
In seguito il nostro programma analizza la correttezza della soluzione svolgendo la verifica su:
\begin{itemize}
\item{\textit{valori assunti dalle variabili}\\
ciascun $x_{ij}$ assume valore $0$ o $1$ con una tolleranza di $\epsilon=10^{-5}$}
\item{\textit{grado di ciascun nodo}\\
il tour è composto al massimo da due archi che tocchino lo stesso nodo}
\end{itemize}
}
\item{\textbf{Gap relativo}\\
La seguente funzione permette di ottenere il gap relativo della funzione obiettivo per un'ottimizzazione MIP.\\
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=350pt, basicstyle=\footnotesize\sffamily,]
int CPXgetmiprelgap( CPXCENVptr env, CPXCLPptr lp, double * gap_p );
\end{lstlisting}
\end{tabular}
\end{center}
\begin{table}[h]
\centering
\begin{tabular}{rl}
\textbf{env:} & {puntatore alla struttura ENV precedentemente creata}\\
\textbf{lp:} & {puntatore alla struttura LP precedentemente creata}\\
\textbf{gap\_p:} & {puntatore alla variabile in cui verrà salvato il gap}\\
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\
\end{tabular}
\end{table}
Per un problema di minimizzazione il gap relativo viene calcolato come:
$$\frac{|bestbound - bestinteger|}{10^{-10}+|bestinteger|}$$
dove \textbf{bestinteger} è il valore restituito dalla funzione \textbf{CPXgetobjval()} mentre \textbf{bestbound} da \textbf{CPXgetbestobjval()}.
}
\end{itemize}

\subsection{Lazy constraint}
Nel caso in cui si voglia verificare il soddisfacimento di un vincolo solo al termine della computazione della soluzione, è necessario inserire un "\textit{lazy constraint}". Questi vincoli vengono 
dichiarati in fase di costruzione del modello e aggiunti ad un pool. Per fare ciò viene utilizzata la seguente funzione:
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=390pt, basicstyle=\footnotesize\sffamily,]  
int CPXaddlazyconstraints( CPXCENVptr env, CPXLPptr lp, int rcnt, int nzcnt, 
		double const * rhs, char const * sense, int const * rmatbeg, 
		int const * rmatind, double const * rmatval, char ** rowname );
\end{lstlisting}
\end{tabular}
\end{center}
\begin{table}[h]
\centering
\begin{tabular}{rl}
\textbf{env:} & {puntatore alla struttura ENV precedentemente creata}\\
\textbf{lp:} & {puntatore alla struttura LP precedentemente creata}\\
\textbf{rcnt:} & {numero di vincoli da inserire}\\
\textbf{nzcnt:} & {numero di coefficienti non nulli nel vincolo}\\ 
\textbf{rhs:} & {vettore dei termini noti dei vincoli}\\
\textbf{sense:} & {vettore di caratteri che specifica il tipo di vincoli da inserire.}\\
&{Ogni carattere può assumere uno dei seguenti valori:}\\
&{\textit{'L'} per un vincolo $\leq$}\\
&{\textit{'E'} per un vincolo $=$}\\
&{\textit{'G'} per un vincolo $\geq$}\\
&{\textit{'R'} per un vincolo definito in un intervallo}\\
\textbf{rmatbeg:} & {vettore con le posizioni iniziali dei coefficienti nei vincoli}\\
\textbf{rmatind:} & {vettore contenente gli indici delle variabili appartenenti al vincolo}\\
\textbf{rmatval:} & {vettore con i coefficienti delle variabili del vincolo}\\
\textbf{rowname:} & {vettore con i nomi dei vincoli}\\
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\
\end{tabular}
\end{table}
In modo analogo alle due funzioni precedentemente descritte per l'aggiunta di righe e colonne, nel nostro modello viene inserito un vincolo per volta. Per impostare correttamente i coefficienti delle variabili presenti nel vincolo, vengono sfruttati i due array \textit{rmatinds} e \textit{rmatval}. Come rappresentato in Figura \ref{lazy_constraints}, all'interno della posizione \textit{i}-esima del vettore di indici è presente la posizione dell'\textit{i}-esima variabile del vincolo da inserire (nell'esempio in figura $rmatinds[i]=j$). Mentre l'\textit{i}-esima posizione del vettore di valori contiene il valore del corrispondente coefficiente ($c_j$).
\begin{figure}[h] 
\begin{center} 
  % Requires \usepackage{graphicx} 
  \includegraphics[scale=0.5]{Images/lazy_constraints} 
  \caption{\footnotesize{Array dei lazy constraint.}}
  \label{lazy_constraints} 
\end{center} 
\end{figure}
\subsection{Lazy Constraint Callback}
Per poter utilizzare una lazy constraint callback, precedentemente implementata all'interno del programma, prima di tutto è necessario installarla. Questo viene fatto attraverso la seguente funzione:
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=385pt, basicstyle=\footnotesize\sffamily,] 
int CPXsetlazyconstraintcallbackfunc( CPXENVptr env,
		int(CPXPUBLIC *lazyconcallback)(CALLBACK_CUT_ARGS), void * cbhandle);    
\end{lstlisting}
\end{tabular}
\end{center}
\begin{table}[h]
\centering
\begin{tabular}{rl}
\textbf{env:} & {puntatore alla struttura ENV}\\
\textbf{lazyconcallback:} & {puntatore alla callback chiamata}\\
\textbf{cbhandle:} & {puntatore ad una struttura dati contenente le informazioni}\\
& {da passare alla callback}\\
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\
\end{tabular}
\end{table}
CPLEX, non sapendo se la funzione implementata dall'utente sia thread safe, impedisce di default lo svolgimento di elaborazioni in parallelo utilizzando le callback. Se l'utente volesse svolgere le azioni in multithreading, deve impostare il parametro \textit{CPX\_PARAM\_THREADS} appena l'installazione della callback, mediante la funzione descritta nella Sezione \ref{param}. Per poter conoscere il numero di thread della macchina su cui si sta lavorando, CPLEX fornisce la seguente funzione:\\
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=280pt, basicstyle=\footnotesize\sffamily,]
int CPXgetnumcores(CPXCENVptr env, int * numcores_p); 
\end{lstlisting}
\end{tabular}
\end{center}
\begin{table}[h]
\centering
\begin{tabular}{rl}
\textbf{env:} & {puntatore ad una struttura ENV}\\
\textbf{numcores\_p:} & {puntatore alla variabile in cui scrivere il numero di core}\\ 
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\           
\end{tabular}
\end{table} 
Le callback sono funzioni lasciate appositamente vuote da CPLEX, affinché l'utente possa implementarle in maniera personalizzata. Queste però hanno una dichiarazione standard, qui riportata:
\begin{center}
\begin{lstlisting}[linewidth=400pt, basicstyle=\footnotesize\sffamily,]     
static int CPXPUBLIC name_function(CPXCENVptr env, void* cbdata, int wherefrom,
		 void* cbhandle, int* useraction_p);
\end{lstlisting}
\end{center}
\begin{table}[h]
\centering
\begin{tabular}{rl}
\textbf{env:} & {puntatore una struttura ENV}\\
\textbf{cbdata:} & {puntatore che contiene specifiche informazioni necessarie alla callback}\\
\textbf{wherefrom:} & {contiene dove è stata invocata la callback durante l'ottimizzazione} \\ 
\textbf{cbhandle:} & {puntatore a dati privati dell'utente} \\
\textbf{useraction\_p:} & {puntatore ad un intero che specifica a CPLEX come proseguire la }\\
&{computazione al termine della callback dell'utente}\\ 
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\                      
\end{tabular}
\end{table} 

L'utente deve impostare il valore di \textit{useraction\_p} con una delle seguenti macro:
\begin{itemize}
\item{\textbf{CPX\_CALLBACK\_DEFAULT}:\\
l'utente dichiara a CPLEX di non aver trovato nessuna soluzione;}
\item{\textbf{CPX\_CALLBACK\_FAIL}:\\
CPLEX esce dall'ottimizzazione;}
\item{\textbf{CPX\_CALLBACK\_SET}:\\
l'utente dichiara a CPLEX di aver trovato una soluzione e gli chiede di usare la soluzione fornita;}
\end{itemize}

Nell'implementare la callback bisogna prestare attenzione nello svolgere azioni thread safe, nel caso in cui si voglia sfruttare l'architettura parallela del processore.
Per avere accesso alla soluzione attuale dal nodo che invoca la callback è possibile chiamare la seguente funzione:
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=410pt, basicstyle=\footnotesize\sffamily,]     
int CPXgetcallbacknodex(CPXCENVptr env, void * cbdata, int wherefrom, double * x, 
		int begin, int end);
\end{lstlisting}
\end{tabular}
\end{center}
\vspace{0.4 cm}
\begin{table}[h]
\centering
\begin{tabular}{rl}
\textbf{env:} & {puntatore una struttura ENV}\\
\textbf{cbdata:} & {puntatore a specifiche informazioni necessarie alla callback}\\
\textbf{wherefrom:} & {punto dell'ottimizzazione in cui è stata invocata la callback} \\ 
\textbf{x:} & {vettore in cui memorizzare le variabili} \\
\textbf{begin:} & {indice della prima variabile da memorizzare}\\
\textbf{end:} & {indice dell'ultima variabile da memorizzare}\\  
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\                               
\end{tabular}
\end{table}
Per ottenere informazioni riguardanti il problema di ottimizzazione che si sta risolvendo all'interno di una callback implementata dall'utente, è possibile utilizzare la seguente funzione:
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=415pt, basicstyle=\footnotesize\sffamily,]  
int CPXgetcallbackinfo(CPXCENVptr env, void * cbdata, int wherefrom, int whichinfo, 
		void * result_p);
\end{lstlisting}
\end{tabular}
\end{center}
\begin{table}[h]
\centering
\begin{tabular}{rl}
\textbf{env:} & {puntatore ad una struttura ENV}\\
\textbf{cbdata:} & {puntatore a specifiche informazioni necessarie alla callback}\\
\textbf{wherefrom:} & {punto dell'ottimizzazione in cui è stata invocata la callback}\\ 
\textbf{whichinfo:} & {macro che specifica l'informazione che si desidera conoscere} \\
\textbf{result\_p:} & {puntatore di tipo void in cui verrà memorizzata l'informazione richiesta}\\ 
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\          
\end{tabular}
\end{table}
Alcune macro utili che possono essere inserite come \textit{whichinfo} sono:
\begin{itemize}
\item{\textbf{CPX\_CALLBACK\_INFO\_MY\_THREAD\_NUM}: \\
identifica il thread che ha eseguito la chiamata;}
\item{\textbf{CPX\_CALLBACK\_INFO\_BEST\_INTEGER}: \\
valore della miglior soluzione intera;}
\end{itemize}
Per conoscere il costo della soluzione legata al nodo corrente che invoca la callback, può essere utilizzata la seguente funzione:
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=380pt, basicstyle=\footnotesize\sffamily,] 
int CPXgetcallbacknodeobjval(CPXCENVptr env, void * cbdata, int wherefrom, 
		double * objval_p); 
\end{lstlisting}
\end{tabular}
\end{center}
\begin{table}[H]
\centering
\begin{tabular}{rl}
\textbf{env:} & {puntatore ad una struttura ENV}\\
\textbf{cbdata:} & {puntatore a specifiche informazioni necessarie alla callback}\\
\textbf{wherefrom:} & {punto dell'ottimizzazione in cui è stata invocata la callback} \\ 
\textbf{objval\_p:} & {puntatore ad una variabile in cui memorizzare il costo} \\
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\  
\end{tabular}
\end{table}
All'interno della lazy callback è necessario aggiungere il taglio voluto al nodo corrente che la invoca. Questo può essere fatto in due diverse modalità: globale o locale.\\
Nel primo caso il vincolo aggiunto sarà visibile da tutti i nodi. Inoltre, in caso non lo ritenga più necessario, CPLEX potrà eliminarlo dal modello. Quest'operazione viene detta \textit{purge} e si verifica, ad esempio, quando un taglio non viene applicato per molte iterazioni consecutive. Per un vincolo globale viene chiamata la seguente funzione, che ne aggiunge uno alla volta:
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=400pt, basicstyle=\footnotesize\sffamily,]  
int CPXcutcallbackadd( CPXCENVptr env, void * cbdata, int wherefrom, int nzcnt, 
		double rhs, int sense, int const * cutind, double const * cutval, 
		int purgeable );
\end{lstlisting}
\end{tabular}
\end{center}
\begin{table}[H]
\centering
\begin{tabular}{rl}
\textbf{env:} & {puntatore ad una struttura ENV}\\
\textbf{cbdata:} & {puntatore a specifiche informazioni necessarie alla callback}\\
\textbf{wherefrom:} & {punto dell'ottimizzazione in cui è stata invocata la callback} \\ 
\textbf{nzcnt:} & {numero di coefficienti non nulli} \\
\textbf{rhs:} & {valore del termine noto} \\
\textbf{sense:} & {tipologia del taglio da aggiungere, a scelta tra:} \\
&{\textit{'L'} per il vincolo $\leq$}\\
&{\textit{'E'} per il vincolo $=$}\\
&{\textit{'G'} per il vincolo $\geq$}\\
\textbf{cutind:} & {vettore contente gli indici dei coefficienti del taglio} \\
\textbf{cutval:} & {vettore contenente i coefficienti delle variabili nel taglio} \\
\textbf{purgeable:} & {intero che specifica in che modo CPLEX deve trattare il taglio, consigliato 0} \\
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\  
\end{tabular}
\end{table}
Nella modalità locale invece, il taglio aggiunto sarà visibile solo ai nodi discendenti di quello che invoca la callback. In questo caso il taglio viene aggiunto mediante la seguente chiamata:
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=400pt, basicstyle=\footnotesize\sffamily,] 
int CPXcutcallbackaddlocal( CPXCENVptrenv, void *cbdata, int wherefrom, 
		int nzcnt, double rhs, int sense, int const *cutind, double const *cutval ); 
\end{lstlisting}
\end{tabular}
\end{center}
\begin{table}[h]
\centering
\begin{tabular}{rl}
\textbf{env:} & {puntatore ad una struttura ENV}\\
\textbf{cbdata:} & {puntatore a specifiche informazioni necessarie alla callback}\\
\textbf{wherefrom:} & {punto dell'ottimizzazione in cui è stata invocata la callback} \\ 
\textbf{nzcnt:} & {numero di coefficienti non nulli} \\
\textbf{rhs:} & {valore del termine noto} \\
\textbf{sense:} & {tipologia del taglio da aggiungere, a scelta tra} \\
&{\textit{'L'} per il vincolo $\leq$}\\
&{\textit{'E'} per il vincolo $=$}\\
&{\textit{'G'} per il vincolo $\geq$}\\
\textbf{cutind:} & {vettore contente gli indici dei coefficienti del taglio} \\
\textbf{cutval:} & {vettore contenente i coefficienti delle variabili nel taglio} \\
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\ 
\end{tabular}
\end{table}
\subsection{Heuristic Callback}
Per poter suggerire a CPLEX una soluzione del problema calcolata dall'utente, è necessario utilizzare un particolare tipo di callback, detta \textit{heuristic callback}. Questa, dopo essere stata installata, verrà invocata ogni volta che viene trovata una nuova soluzione per il sottoproblema corrente.\\
Per installare la callback viene utilizzata la seguente funzione:
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=330pt, basicstyle=\footnotesize\sffamily,]    
int CPXsetheuristiccallbackfunc(CPXENVptr env,
		 int(CPXPUBLIC *heuristiccallback)(CALLBACK_HEURISTIC_ARGS), 
		 void * cbhandle);
\end{lstlisting}
\end{tabular}
\end{center}
\begin{table}[h]
\centering
\begin{tabular}{rl}
\textbf{env:} & {puntatore ad una struttura ENV}\\
\textbf{heuristiccallback:} & {puntatore all'heuristic callback scritta dall'utente}\\
\textbf{cbhandle:} & {puntatore a dati privati dell'utente}\\
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\
\end{tabular}
\end{table}
La callback creata dall'utente deve rispettare la seguente dichiarazione:
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=382pt, basicstyle=\footnotesize\sffamily,] 
 int callback (CPXCENVptr env, void *cbdata, int wherefrom, void *cbhandle, 
 		double *objval_p, double *x, int *checkfeas_p, int *useraction_p);
\end{lstlisting}
\end{tabular}
\end{center}
\begin{table}[h]
\centering
\begin{tabular}{rl}
\textbf{env:} & {puntatore ad una struttura ENV}\\
\textbf{cbdata:} & {puntatore a specifiche informazioni necessarie alla callback}\\
\textbf{wherefrom:} & {punto dell'ottimizzazione in cui è stata invocata la callback} \\ 
\textbf{cbhandle:} & {puntatore a dati privati dell'utente}\\
\textbf{objval\_p:} & {puntatore ad una variabile che inizialmente contiene il costo della soluzione}\\
&{attuale e in seguito verrà riempito con il costo della soluzione}\\
&{trovata dall'utente}\\
\textbf{x:} & {vettore contenente inizialmente la soluzione attuale del problema}\\
&{ed in seguito sostituito dalla soluzione trovata dall'utente}\\
\textbf{checkfeas\_p:} & {puntatore che specifica se CPLEX debba verificare la fattibilità della}\\
&{soluzione trovata oppure no}\\
\textbf{useraction\_p:} & {puntatore ad un intero che specifica a CPLEX come proseguire la }\\
&{computazione al termine della callback dell'utente.}\\
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\
\end{tabular}
\end{table}

L'utente deve impostare il valore di \textit{useraction\_p} con una delle seguenti macro:
\begin{itemize}
\item{\textbf{CPX\_CALLBACK\_DEFAULT}:\\
l'utente dichiara a CPLEX di non aver trovato nessuna soluzione;}
\item{\textbf{CPX\_CALLBACK\_FAIL}:\\
CPLEX esce dall'ottimizzazione;}
\item{\textbf{CPX\_CALLBACK\_SET}:\\
l'utente dichiara a CPLEX di aver trovato una soluzione e chiede di usare la soluzione fornita;}
\end{itemize}

\subsection{Generic Callback}% cambiare titolo da Lazy Constraint Callback General a general callback
Per evitare che alcune procedure interne a CPLEX vengano disattivate nel momento dell'installazione di una callback, recentemente è stata sviluppata una particolare tipologia di callback, detta \textit{generic}. Questa non è relativa a una specifica versione di callback, come quelle descritte nelle sezioni precedenti, ma può essere invocata in contesti diversi e con diversi scopi.\\
Per installare una generic callback viene utilizzata la seguente funzione, in cui  è necessario specificare il contesto in cui invocare la callback:
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=380pt, basicstyle=\footnotesize\sffamily,]    
int CPXcallbacksetfunc ( CPXENVptr env, CPXLPptr lp, CPXLONG contextmask, 
		CPXCALLBACKFUNC *callback, void * userhandle );
\end{lstlisting}
\end{tabular}
\end{center}
\begin{table}[h]
\centering
\begin{tabular}{rl}
\textbf{env:} & {puntatore ad una struttura ENV}\\
\textbf{lp:} & {puntatore alla struttura LP}\\
\textbf{contextmask:} & {contesto sul quale deve essere invocata la callback (è possibile metterne}\\
&{più di uno utilizzando l'or bitwise e gestire poi i singoli casi }\\
&{dall'interno della funzione)}\\
\textbf{callback:} & {puntatore alla callback scritta dall'utente} \\
\textbf{userhandle:} & {puntatore ad una struttura che contiene i dati da passare alla callback} \\
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\
\end{tabular}
\end{table}
Alcuni possibili valori di \textit{contextmask} sono:
\begin{itemize}
\item{\textbf{CPX\_CALLBACKCONTEXT\_CANDIDATE}:\\la callback verrà invocata quando viene trovata da CPLEX una nuova soluzione ammissibile che l'utente poi potrà rifiutare;}
\item{\textbf{CPX\_CALLBACKCONTEXT\_LOCAL\_PROGRESS}: \\la callback verrà invocata nel momento in cui un thread effettua un progresso, non ancora noto globalmente, nella soluzione del problema. In questo contesto l'utente può suggerire a CPLEX una soluzione da cui proseguire la computazione (analogamente alle heuristic callback).}\\
\end{itemize}
La callback implementata dall'utente deve avere questa dichiarazione:
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=350pt, basicstyle=\footnotesize\sffamily,]    
static int CPXPUBLIC name_general_callback(CPXCALLBACKCONTEXTptr
                     context, CPXLONG contextid, void* userhandle);
\end{lstlisting}
\end{tabular}
\end{center}
\begin{table}[h]
\centering
\begin{tabular}{rl}
\textbf{context:} & {puntatore alla struttura del contesto della callback}\\
\textbf{contextid:} & {intero che specifica il contesto in cui viene invocata la callback}\\
\textbf{userhandle:} & {argomento passato alla callback nell'installazione}\\
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\
\end{tabular}
\end{table}
L'utente può installare una sola callback, ma al suo interno può distinguere il contesto in cui è stata invocata grazie al parametro \textit{contextid}.\\
Per poter accedere alla soluzione candidata e al suo costo, deve essere presente la seguente chiamata, che è specifica per il contesto \textbf{CPX\_CALLBACKCONTEXT\_CANDIDATE}:
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=380pt, basicstyle=\footnotesize\sffamily,]
int CPXcallbackgetcandidatepoint( CPXCALLBACKCONTEXptr context, double *x, 
		CPXDIM begin, CPXDIM end, double *obj_p);    
\end{lstlisting}
\vspace{0.2 cm}
\end{tabular}
\end{center}
\begin{table}[h]
\centering
\begin{tabular}{rl}
\textbf{context:} & {contesto (lo stesso passato alla callback scritta dall'utente)}\\
\textbf{x:} & {vettore dove memorizzare le variabili richieste}\\
\textbf{begin:} & {indice prima variabile richiesta}\\
\textbf{end:} & {indice dell'ultima variabile richiesta}\\
\textbf{obj\_p:} & {puntatore alla variabile in cui memorizzare il costo della}\\
&{soluzione candidata, può essere NULL}\\
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\
\end{tabular}
\end{table}
Per poter scartare una soluzione, nel caso in cui violi alcuni tagli specificati nella chiamata stessa, viene utilizzata la seguente funzione. Anche questa è specifica per il contesto 
\\\textbf{CPX\_CALLBACKCONTEXT\_CANDIDATE}.
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=420pt, basicstyle=\footnotesize\sffamily,] 
int CPXcallbackrejectcandidate( CPXCALLBACKCONTEXTptr context, int rcnt, int nzcnt, 
		double const *rhs, char const *sense, int const *rmatbeg, int const *rmatind, 
		double const *rmatval );   
\end{lstlisting}
\end{tabular}
\end{center}
\begin{table}[h]
\centering
\begin{tabular}{rl}
\textbf{context:} & {contesto (lo stesso passato alla callback scritta dall'utente)}\\
\textbf{rcnt:} & {numero di vincoli che tagliano la soluzione}\\
\textbf{nzcnt:} & {numero di coefficienti non nulli nel vincolo}\\
\textbf{rhs:} & {vettore dei termini noti}\\
\textbf{sense:} & {vettore con la tipologia dei vincoli}\\
\textbf{rmatbeg:} & {vettore di indici che specifica dove inizi ogni vincolo}\\
\textbf{rmatind:} & {vettore di indici delle colonne con coefficienti non nulli}\\
\textbf{rmatval:} & {coefficienti non nulli delle colonne specificate}\\
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\
\end{tabular}
\end{table}
Per suggerire a CPLEX una soluzione da sfruttare nel proseguimento della computazione dev'essere utilizzata la seguente funzione:
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=365pt, basicstyle=\footnotesize\sffamily,]
int CPXcallbackpostheursoln( CPXCALLBACKCONTEXTptr context, CPXDIM cnt, 
			CPXDIM const * ind, double const * val, double obj, 
			CPXCALLBACKSOLUTIONSTRATEGY strat );    
\end{lstlisting}
\end{tabular}
\end{center}
\begin{table}[h]
\centering
\begin{tabular}{rl}
\textbf{context:} & {contesto (lo stesso passato alla callback scritta dall'utente)}\\
\textbf{cnt:} & {numero di elementi nei vettori ind e val}\\
\textbf{ind:} & {vettore di indici non nulli dei valori della soluzione}\\
\textbf{val:} & {vettore di valori non nulli della soluzione (possono essere NaN nel caso in cui }\\
&{la soluzione sia parziale)}\\
\textbf{obj:} & {costo della nuova soluzione}\\
\textbf{strat:} & {strategia con cui CPLEX deve completare la nuova soluzione, nel caso sia }\\
&{parziale}\\
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\
\end{tabular}
\end{table}

La soluzione proposta dall'utente può anche essere incompleta, CPLEX provvederà poi a completarla seguendo le istruzioni fornite dal parametro \textit{strat}. Questo può assumere i seguenti valori:
\begin{itemize}
\item{\textbf{CPXCALLBACKSOLUTION\_NOCHECK}: \\
in questo caso CPLEX non controllerà la fattibilità della soluzione proposta, che deve però essere completa;}
\item{\textbf{CPXCALLBACKSOLUTION\_CHECKFEAS}:\\
in questo caso CPLEX si limiterà a controllare la fattibilità della soluzione proposta, senza completarla, la soluzione non può perciò essere parziale;}
\item{\textbf{CPXCALLBACKSOLUTION\_PROPAGATE}:\\
se la soluzione fornita è parziale, in questo caso CPLEX cercherà di completare la soluzione attraverso la propagazione del bound;}
\item{\textbf{CPXCALLBACKSOLUTION\_SOLVE}:\\
se la soluzione fornita è parziale, CPLEX fisserà le variabili specificate nella soluzione e cercherà di risolvere il risultante problema ridotto;}
\end{itemize}
CPLEX utilizzerà la soluzione proposta dall'utente solo nel caso in cui questa abbia costo inferiore all'incumbent.
\section{Parametri}\label{param}
Con le seguenti funzioni è possibile modificare i parametri di configurazione di CPLEX, altrimenti impostati ai valori di default.
Nel caso in cui si tratti di parametri di tipo \texttt{int} è necessario invocare:\\
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=330pt, basicstyle=\footnotesize\sffamily,]     
int CPXsetintparam(CPXENVptr env, int whichparam, int newvalue);
\end{lstlisting}
\end{tabular}
\end{center}
mentre se di tipo \texttt{double}:\\
\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[linewidth=340pt, basicstyle=\footnotesize\sffamily,]  
int CPXsetdblparam(CPXENVptr env, int whichparam, double newvalue);
\end{lstlisting}
\end{tabular}
\end{center}
In entrambe le funzioni:
\begin{table}[h]
\centering
\begin{tabular}{rl}
\textbf{env:} & {puntatore alla struttura ENV di cui si vogliono cambiare i parametri}\\
\textbf{whichparam:} & {id del parametro da modificare (vedi Tabella \ref{param_table})}\\
\textbf{newvalue:} & {nuovo valore (rispettivamente intero o double) del parametro}\\
\textbf{Return Value:} & {0 in caso di successo, un valore diverso da 0 altrimenti}\\
\end{tabular}
\end{table}
{\footnotesize
\begin{longtable}[h]{rl}
\hline
\multicolumn{1}{c}{\textbf{Parametro}}&\multicolumn{1}{c}{\textbf{Descrizione}}\\
\hline
{\textbf{CPX\_PARAM\_EPGAP}} & {tolleranza dell'intervallo tra la migliore funzione obiettivo intera}\\
& { e la funzione obiettivo del miglior nodo rimanente.}\\
\textbf{CPX\_PARAM\_INTSOLLIM}&{numero di soluzioni MIP intere che CPLEX deve trovare prima}\\
&{di terminare la computazione.}\\
\textbf{CPX\_PARAM\_MIPCBREDLP} & {permette, dalla callback che la chiama, di accedere al modello originale }\\
&{del problema e non a quello ridotto.}\\
{\textbf{CPX\_PARAM\_NODELIM}} & {massimo numero di nodi da risolvere prima che l'algoritmo termini}\\
& {senza aver aggiunto l'ottimalità (0 impone di fermarsi alla radice).}\\
\textbf{CPX\_PARAM\_POLISHTIME} & {tempo in secondi dedicato da CPLEX nel fare il polish della soluzione.}\\
{\textbf{CPX\_PARAM\_POPULATELIM}} & {numero di soluzioni MIP generate per il pool di soluzioni durante}\\
& {ogni chiamata alla procedura populate.}\\
\textbf{CPX\_PARAM\_RANDOMSEED}&{random seed utilizzato da CPLEX.}\\
\textbf{CPX\_PARAM\_RINSHEUR} & {frequenza (ogni quanti nodi) con cui deve essere invocato da CPLEX}\\
&{l'algoritmo euristico Rins.}\\
\textbf{CPX\_PARAM\_SCRIND} & {abilita la stampa dei messaggi di log di CPLEX.}\\
\textbf{CPX\_PARAM\_THREADS} & {numero massimo di thread utilizzabili. }\\
\textbf{CPX\_PARAM\_TIMELIMIT}&{tempo massimo che CPLEX ha a disposizione nel calcolo della soluzione.}\\
\hline
\caption{Parametri.}\label{param_table}
\end{longtable}}

\section{Costanti utili}
Di seguito vengono riportate alcune macro utili di CPLEX, insieme ai loro corrispondenti valori:
\begin{table}[h]
\footnotesize\centering
\begin{tabular}{rcl}
\hline
\multicolumn{1}{c}{\textbf{Macro}}&\multicolumn{1}{c}{\textbf{Valore}} &\multicolumn{1}{c}{\textbf{Descrizione}}\\
\hline
\textbf{CPX\_ON} & {\textbf{1}} & {valore da assegnare ad alcuni parametri per abilitarli}\\
\textbf{CPX\_OFF} & {0} & {valore da assegnare ad alcuni parametri per disabilitarli}\\
\textbf{CPX\_INFBOUND} & {$+\infty$ } & {massimo valore intero utilizzabile in CPLEX ($10^{20}$)}\\
\hline
\end{tabular}
\caption{Macro.}
\end{table}
