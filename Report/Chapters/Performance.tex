\chapter{Performance}\label{PERF_PROF}
Le metriche di confronto, utilizzate nell'analisi degli algoritmi, sono il tempo complessivo di creazione e risoluzione del modello ed il costo della soluzione ottenuta. Ciascuna modalità di risoluzione viene applicata a diverse istanze di TSPlib, con un numero differente di nodi.  
\section{Performance variabilty}
Nel corso degli anni '90, gli ingegneri di CPLEX scoprirono che il tempo di risoluzione variasse significativamente in diversi sistemi operativi. Con alcune istanze, le performance migliori si avevano su UNIX mentre con altre su Windows.\\
Il motivo di tale comportamento venne in seguito studiato ed attribuito alla diversa scelta effettuata dai sistemi operativi nel decretare l'ordine delle variabili su cui viene svolto l'albero decisionale.\\
Le scelte svolte inizialmente, nella definizione dei primi nodi dell'albero, si ripercuotono sulla sua successiva evoluzione.\\
Proprio per questo motivo, su alcune istanze, UNIX riusciva a risolvere il problema in tempo minore rispetto a Windows, mentre su altre accadeva l'opposto.\\
Da questi studi, evinse che il Branch and Cut è un sistema caotico e che quindi piccole variazioni delle condizioni iniziali generano grandi differenze nei risultati finali.\\
Per questo motivo, alcuni algoritmi prensentati in questo report, sono stati studiati al variare di alcune condizioni iniziali:
\begin{itemize}
\item{\textbf{Random Seed}\\
definisce il seme da cui CPLEX genera una sequenza di numeri pseudo-casuali (vedi Sezione \ref{param}). Nel momento in cui CPLEX nota che diverse variabili frazionarie hanno lo stesso valore, il risolutore sceglie casualmente su quale di queste applicare il Branch.}
\item{\textbf{Gap}\\
intervallo massimo, tra il valore della migliore funzione obiettivo intera e il valore della funzione di costo del miglior nodo rimanente, che permette di decretare il raggiungimento dell'ottimo secondo CPLEX (vedi Sezione \ref{param}).}
\end{itemize}
La variazione del primo di questi parametri permette di apportare significative modifiche al tempo di risoluzione, non modficando la reale ottimalità della soluzione.\\
La variazione dell'altro parametro permette invece di ottenere una soluzione euristica, ovvero un'approssimazione più lasca di quella ottima.
 
\section{Analisi tabulare}
Un metodo non molto efficiente per lo studio delle performance degli algoritmi, utilizza una struttura tabulare in cui viene inserita una riga per ogni istanza del problema.\\ Inoltre vengono riportati i tempi di esecuzione degli algoritmi su ognuno dei grafi analizzati. Nell'ultima riga per ciascun algoritmo viene riportata la media geometrica dei suoi tempi di esecuzione (vedi esempio in Tabella \ref{result_table}).\\
Solitamente viene impostato un TIME LIMIT uguale per tutti gli algoritmi. Questo rappresenta nella tabella il valore del tempo di esecuzione per un algoritmo che ha impiegato un tempo maggiore o uguale a TIME LIMIT. Spesso viene dato più peso al TIME LIMIT, inserendolo nella tabella con, ad esempio, peso 10 (ovvero TIME LIMIT*10).\\ La debolezza di tale calcolo delle performance risiede nel fatto che non sempre la media descrive  l'efficienza di un soluzione. Infatti non influisce unicamente il tempo di risoluzione del modello ma anche quello necessario alla sua creazione. 

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|}
\multicolumn{1}{c}{\textbf{Istanza}} & \multicolumn{1}{c}{\textbf{Sequential}} & \multicolumn{1}{c}{\textbf{Flow}} &
\multicolumn{1}{c}{\textbf{Loop}}\\
\hline
\textbf{att48} & {212.3} & {12.5} & {4.3}\\
\hline
{\textbf{...}} & {...} & {...} & {...}\\
\hline
\textbf{a280} & {3200} & {2500.8} & {1300.5}\\
\hline
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{2120.3} & \multicolumn{1}{c}{1800.3}& \multicolumn{1}{c}{1000.4}\\
\end{tabular}
\caption{\footnotesize{Tabella di performance con \textbf{TIME LIMIT=3200}.}}\label{result_table}
\end{table}

\section{Performance profiling}
Questo metodo prevede la classificazione dei tempi di esecuzione degli algoritmi in base al numero percentuale di successi, rispetto a un fattore moltiplicativo (ratio) del tempo di esecuzione (vedi Figura \ref{perf_profile}).\\
L'andamento del performance profile di un algoritmo è monotono crescente. Il valore assunto per ogni ratio dagli algoritmi all'interno del grafico è la percentuale del numero di istanze che l'algoritmo risolve con quel fattore rispetto all'ottimo di quel caso.\\
Spesso questi grafici vengono rappresentati in scala logaritmica per notare al meglio le differenze ed avere una migliore raffigurazione.\\
\begin{figure}[h] 
\begin{center} 
  % Requires \usepackage{graphicx} 
  \includegraphics[scale=0.3]{Images/perf_profile} 
  \caption{\footnotesize{Performance profile di due algoritmi.}}
  \label{perf_profile} 
\end{center} 
\end{figure}
Per creare il performance profile degli algoritmi implementati, è stato utilizzato il programma python riportato nella Sezione \ref{perf_profile_py}. 

\section{Analisi degli algoritmi sviluppati}
Nella seguente sezione vengono riportati i grafici relativi ai risultati ottenuti con le implementazioni degli algoritmi descritti nei precedenti capitoli. I valori ottenuti ed utilizzati per realizzare le immagini contenute in questa sezione, sono consultabili nell'Appendice \ref{results}.
\subsection{Algoritmi esatti}
Gli algoritmi basati sul modello compatto, sono stati testati con un time limit di 20 minuti sulle seguenti istanze:
\begin{center}
\begin{multicols}{3}
\begin{itemize}
\item{att48.tsp}
\item{berlin52.tsp}
\item{burma14.tsp}
\item{eil101.tsp}
\item{eil51.tsp}
\item{eil76.tsp}
\item{gr96.tsp}
\item{kroA100.tsp}
\item{kroB100.tsp}
\item{kroB150.tsp}
\item{kroC100.tsp}
\item{kroD100.tsp}
\item{kroE100.tsp}
\item{pr124.tsp}
\item{pr136.tsp}
\item{pr76.tsp}
\item{rat99.tsp}
\item{rd100.tsp}
\item{st70.tsp}
\item{ulysses16.tsp}
\end{itemize}
\end{multicols}
\end{center}
Visionando il performance profile in Figura \ref{pp_compact}, risulta evidente come l'aggiunta dei vincoli come lazy constraint, nel metodo di Miller, Tucker e Zemlin, garantisca un notevole miglioramento delle prestazioni rispetto alla versione originale.\\
\begin{figure}[H] 
\begin{center} 
  % Requires \usepackage{graphicx} 
  \includegraphics[scale=0.7]{Images/pp_compact}\\ 
  \caption{\footnotesize{Performance profile degli algoritmi compatti.}}
  \label{pp_compact} 
\end{center} 
\end{figure}
Gli algoritmi esatti, che non prevedono l'uso di modelli compatti, sono invece stati testati con un time limit di 10 minuti sul seguente dataset:
\begin{center}
\begin{multicols}{4}
\begin{itemize}
\item{a280.tsp}
\item{ali535.tsp}
\item{att48.tsp}
\item{att532.tsp}
\item{berlin52.tsp}
\item{bier127.tsp}
\item{burma14.tsp}
\item{ch130.tsp}
\item{ch150.tsp}
\item{d198.tsp}
\item{d493.tsp}
\item{d657.tsp}
\item{eil51.tsp}
\item{eil76.tsp}
\item{eil101.tsp}
\item{fl417.tsp}
\item{gil262.tsp}
\item{gr96.tsp}
\item{gr137.tsp}
\item{gr202.tsp}
\item{gr229.tsp}
\item{gr431.tsp}
\item{gr666.tsp}
\item{kroA100.tsp}
\item{kroA150.tsp}
\item{kroA200.tsp}
\item{kroB100.tsp}
\item{kroB150.tsp}
\item{kroB200.tsp}
\item{kroC100.tsp}
\item{kroD100.tsp}
\item{kroE100.tsp}
\item{lin105.tsp}
\item{lin318.tsp}
\item{p654.tsp}
\item{pcb442.tsp}
\item{pr76.tsp}
\item{pr107.tsp}
\item{pr124.tsp}
\item{pr136.tsp}
\item{pr144.tsp}
\item{pr152.tsp}
\item{pr226.tsp}
\item{pr299.tsp}
\item{pr439.tsp}
\item{rat99.tsp}
\item{rat195.tsp}
\item{rat575.tsp}
\item{rat783.tsp}
\item{rd100.tsp}
\item{rd400.tsp}
\item{st70.tsp}
\end{itemize}
\end{multicols}
\end{center}
Dall'analisi dei risultati ottenuti (Figura \ref{pp_exact}), è evidente come l'utilizzo del Branch \& Cut permetta di ottenere prestazioni migliori, ma soprattutto come l'utilizzo delle callback generiche abbia permesso di migliorare notevolmente le prestazioni, rispetto alla versione priva di esse.\\
L'utilizzo del patching ha avuto maggior effetto soprattutto nella prima parte dell'esecuzione del programma, in cui risulta essere molto di aiuto per CPLEX nel raggiungere l'ottimo. Successivamente le soluzioni passate al risolutore MIP, mediante le heuristic callback, vengono scartate da quest'ultimo sempre più spesso.\\
\begin{figure}[H] 
\begin{center} 
  % Requires \usepackage{graphicx} 
  \includegraphics[scale=0.75]{Images/pp_exact}\\ 
  \caption{\footnotesize{Performance profile dei tempi di esecuzione degli algoritmi esatti implementati.}}
  \label{pp_exact} 
\end{center} 
\end{figure}
In Figura \ref{pp_random_seed} viene confrontato invece l'algoritmo loop attraverso l'utilizzo di diversi seed, ponendo l'attenzione su come la performance variability influenzi le prestazioni delle varie soluzioni implementative.
Il performance profile riportato in Figura \ref{pp_gap} confronta i risultati ottenuti mediante l'utilizzo dell'algoritmo loop nella sua versione classica con quelli ottenuti applicando la sua versione euristica. Nel grafico realizzato, le varianti euristiche individuano inizialmente una soluzione utilizzando il gap relativo evidenziato 
nel grafico ed in seguito impostano nuovamente il gap al valore di default ed individuano la soluzione ottima.
\begin{figure}[H] 
\begin{center} 
  % Requires \usepackage{graphicx} 
  \includegraphics[scale=0.7]{Images/pp_random_seed}\\ 
  \caption{\footnotesize{Performance profile dei tempi di esecuzione dell'algoritmo loop al variare del seed.}}
  \label{pp_random_seed} 
\end{center} 
\end{figure}
\begin{figure}[H] 
\begin{center} 
  % Requires \usepackage{graphicx} 
  \includegraphics[scale=0.7]{Images/pp_gap}\\ 
  \caption{\footnotesize{Performance profile dei tempi di esecuzione dell'algoritmo loop euristico al variare del gap.}}
  \label{pp_gap} 
\end{center} 
\end{figure}

\vspace{2cm}
\subsection{Algoritmi math-euristici}
Gli algoritmi math-euristici sviluppati sono stati testati sul seguente insieme di istanze, con un time limit 10 minuti:
\begin{center}
\begin{multicols}{3}
\begin{itemize}
\item{a280.tsp}  
\item{att532.tsp} 
\item{bier127.tsp}
\item{d198.tsp}   
\item{d493.tsp}   
\item{eil76.tsp}  
\item{eil101.tsp} 
\item{fl417.tsp}  
\item{gr137.tsp}  
\item{gr202.tsp}  
\item{lin105.tsp} 
\item{lin318.tsp} 
\item{pcb442.tsp} 
\item{pr144.tsp}  
\item{pr264.tsp}  
\item{pr299.tsp}  
\item{pr439.tsp}  
\item{rat575.tsp} 
\item{rd400.tsp}  
\item{u159.tsp}
\end{itemize}
\end{multicols}
\end{center}
Analizzando i risultati ottenuti in Figura \ref{pp_math-heuristic} e \ref{pp_math-heuristic_zoom}) risulta evidente come le prestazioni dell'algoritmo Hard fixing siano migliori, sia nella variante che utilizza le callback generiche che in quella che non ne fa uso, rispetto ad entrambe le soluzioni ottenute dal Soft fixing.
\begin{figure}[h] 
\begin{center} 
  % Requires \usepackage{graphicx} 
  \includegraphics[scale=0.8]{Images/pp_math-heuristic}\\ 
  \caption{\footnotesize{Confronto degli algoritmi math-euristici in base al costo della soluzione ottenuta.}}
  \label{pp_math-heuristic} 
\end{center} 
\end{figure}

\begin{figure}[h] 
\begin{center} 
  % Requires \usepackage{graphicx} 
  \includegraphics[scale=0.8]{Images/pp_math-heuristic_zoom}\\ 
  \caption{\footnotesize{Dettaglio del confronto degli algoritmi math-euristici in base al costo della soluzione ottenuta.}}
  \label{pp_math-heuristic_zoom} 
\end{center} 
\end{figure}
\vspace{10cm}
\subsection{Algoritmi euristici}
\subsubsection{Multi-start}\label{construction_perf}
In questa prima sezione, vengono analizzati i diversi algoritmi di costruzione implementati, applicando l'algoritmo multistart sulle seguenti istanze:
\begin{center}
\begin{multicols}{4}
\begin{itemize}
\item{a280.tsp}
\item{ali535.tsp}
\item{att532.tsp}
\item{d1291.tsp}
\item{d1665.tsp}
\item{d2103.tsp}
\item{d493.tsp}
\item{d657.tsp}
\item{dsj1000.tsp}
\item{fl1400.tsp}
\item{fl1577.tsp}
\item{fl417.tsp}
\item{gil262.tsp}
\item{gr431.tsp}
\item{gr666.tsp}
\item{lin318.tsp}
\item{nrw1379.tsp}
\item{p654.tsp}
\item{pcb1173.tsp}
\item{pcb442.tsp}
\item{pr1002.tsp}
\item{pr299.tsp}
\item{pr439.tsp}
\item{rat575.tsp}
\item{rat783.tsp}
\item{rd400.tsp}
\item{rl1304.tsp}
\item{rl1323.tsp}
\item{rl1889.tsp}
\item{u1060.tsp}
\item{u1432.tsp}
\item{u1817.tsp}
\item{u574.tsp}
\item{u724.tsp}
\item{vm1084.tsp}
\item{vm1748.tsp}
\end{itemize}
\end{multicols}
\end{center}

In Figura \ref{pp_construction}, viene riportato il performance profile ottenuto dall'esecuzione dell'algoritmo multistart, generando 40 differenti soluzioni per ciascuna istanza del problema e restituendo solo il costo della migliore tra queste.\\
Le soluzioni di costo minore sono quelle restituite dall'algoritmo Nearest Neighborhood, in particolare con l'aggiunta del metodo GRASP. 
Inoltre si è notato come il tempo necessario alla definizione di una soluzione mediante il metodo insertion sia molto elevato. 
\begin{figure}[h] 
\begin{center} 
  % Requires \usepackage{graphicx} 
  \includegraphics[scale=0.8]{Images/pp_construction}\\ 
  \caption{\footnotesize{Confronto dei vari multistart in base all'algoritmo di costruzione utilizzato.}}
  \label{pp_construction} 
\end{center} 
\end{figure}
\subsubsection{Algoritmi meta-euristici}
Tutti gli algoritmi meta-euristici sviluppati, escluso il genetico, prevedono la possibilità di utilizzare uno qualsiasi tra gli algoritmi di costruzione definiti, semplicemente associando specifici valori a delle macro.\\
Per i motivi descritti nella sezione precedente, gli algoritmi sono stati testati però utilizzando il metodo di costruzione Nearest Neighborhood e con un time limit di 10 minuti. In questi test, è stata impostata una macro che permette al multistart di essere eseguito in multithreading in questo intervallo di tempo, generando iterativamente 8 soluzioni alla volta. Il primo dataset su cui sono stati svolti i test è il seguente:
\begin{center}
\begin{multicols}{3}
\begin{itemize}
\item{d1291.tsp}
\item{d1655.tsp} 
\item{d2103.tsp} 
\item{dsj1000.tsp}
\item{fl1400.tsp} 
\item{fl1577.tsp} 
\item{nrw1379.tsp} 
\item{pcb1173.tsp} 
\item{pr1002.tsp}
\item{pr2392.tsp}
\item{rl1304.tsp}
\item{rl1323.tsp}
\item{rl1889.tsp}
\item{u1060.tsp} 
\item{u1432.tsp}
\item{u1817.tsp}
\item{u2152.tsp}
\item{u2319.tsp}
\item{vm1084.tsp}
\item{vm1748.tsp}
\end{itemize}
\end{multicols}
\end{center}
L'algoritmo genetico non è stato applicato a questo primo dataset. Il motivo di tale scelta, riguarda il tempo di calcolo troppo elevato per la generazione della popolazione.\\
Per tale motivo tutti gli algoritmi meta-euristici sono stati testati nuovamente sulle seguenti istanze di dimensione minore, per ottenere un confronto più equo della soluzione del genetico con le altre:
\begin{center}
\begin{multicols}{3}
\begin{itemize}
\item{a280.tsp}
\item{bier127.tsp}
\item{ch130.tsp}
\item{ch150.tsp}
\item{d198.tsp}
\item{gil262.tsp}
\item{gr137.tsp}
\item{kroA150.tsp}
\item{kroA200.tsp}
\item{kroB150.tsp}
\item{kroB200.tsp}
\item{pr124.tsp}
\item{pr136.tsp}
\item{pr144.tsp}
\item{pr152.tsp}
\item{pr226.tsp}
\item{pr264.tsp}
\item{pr299.tsp}
\item{rd400.tsp}
\item{u159.tsp}
\end{itemize}
\end{multicols}
\end{center}
Analizzando i risultati ottenuti in entrambi i test (Figura \ref{pp_heuristic} e \ref{pp_genetic}), le soluzioni con costo minore sono quelle ottenute mediante il Simulated Annealing e il VNS ibribo. Nel primo caso, con istanze di grandezza maggiore, la seconda implementazione del VNS genera soluzioni di costo minore mentre nel confronto con l'algoritmo genetico, la prima implementazione del VNS risulta migliore.\\
I grafici in Figura \ref{cost_vns}, \ref{cost_tabu}, \ref{cost_sa} e \ref{cost_genetic} rappresentano invece l'andamento del costo applicando rispettivamente il VNS ibrido, il Tabu Search, il Simulated Annealing e l'algoritmo genetico all'istanza \textit{bier127.tsp}.
\begin{figure}[h] 
\begin{center} 
  % Requires \usepackage{graphicx} 
  \includegraphics[scale=0.8]{Images/pp_heuristic}\\ 
  \caption{\footnotesize{Confronto dei costi delle soluzioni ottenute mediante gli algoritmi meta-euristici, escluso il genetico.}}
  \label{pp_heuristic} 
\end{center}
\end{figure}
\begin{figure}[h] 
\begin{center} 
  % Requires \usepackage{graphicx} 
  \includegraphics[scale=0.8]{Images/pp_genetic}\\ 
  \caption{\footnotesize{Confronto dei costi delle soluzioni ottenute mediante tutti gli algoritmi meta-euristici.}}
  \label{pp_genetic} 
\end{center} 
\end{figure}
\begin{figure}[h]
\begin{center} 
  % Requires \usepackage{graphicx} 
  \includegraphics[scale=0.7]{Images/cost_vns}\\ 
  \caption{\footnotesize{Evoluzione del costo della soluzione attuale nell'algoritmo VNS.}}
  \label{cost_vns} 
\end{center} 
\end{figure}
\begin{figure}[h] 
\begin{center} 
  % Requires \usepackage{graphicx} 
  \includegraphics[scale=0.7]{Images/cost_tabu}\\ 
  \caption{\footnotesize{Evoluzione del costo della soluzione attuale nell'algoritmo Tabu search.}}
  \label{cost_tabu} 
\end{center} 
\end{figure}
\begin{figure}[h] 
\begin{center} 
  % Requires \usepackage{graphicx} 
  \includegraphics[scale=0.7]{Images/cost_sa}\\ 
  \caption{\footnotesize{Evoluzione del costo della soluzione attuale nell'algoritmo Simulated Annealing.}}
  \label{cost_sa} 
\end{center} 
\end{figure}
\begin{figure}[h]
\begin{center} 
  % Requires \usepackage{graphicx} 
  \includegraphics[scale=0.7]{Images/cost_genetic}\\ 
  \caption{\footnotesize{Evoluzione del costo medio della popolazione e del costo della soluzione migliore nell'algoritmo genetico.}}
  \label{cost_genetic} 
\end{center} 
\end{figure}